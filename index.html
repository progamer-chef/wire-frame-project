<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    /* Basic Reset: Remove default margin/padding and use border-box sizing */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    /* Set a minimum page size so scrollbars appear if the window gets too small */
    html, body {
      min-width: 500px;  /* Minimum width */
      min-height: 375px; /* Minimum height */
    }
    
    /* Body fills the viewport and centers its content */
    body {
      font-family: monospace;
      height: 100vh;       /* Fill the viewport height */
      width: 100vw;        /* Fill the viewport width */
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: hsl(0, 0%, 97%);
      position: relative;  /* So absolute elements inside use this as reference */
      overflow: auto;      /* Show scrollbars if content is larger than viewport */
    }
    
    /* The main container (our "box") */
    .main-container {
      width: 80vw;         /* 80% of viewport width */
      height: 65vh;        /* 65% of viewport height */
      min-width: 400px;
      min-height: 244px;
      border: 2px solid black;
      background-color: white;
      position: relative;  /* So we can measure its corners */
      display: flex;
      flex-direction: column; /* Divide vertically */
      justify-content: center; /* Content will be centered vertically within each half */
    }
    
    /* Top half: for text input using contenteditable div */
    .top-half {
      flex: 1;              /* Take half the available vertical space */
      color: black;
    }
    
    /* The contenteditable div for text input */
    .editable {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: "Times New Roman", Times, serif;
      color: black;
      font-weight: bold;
      font-size: 1rem;
      border: none;  /* Remove any border */
      outline: none; /* Remove focus outline */
    }
    
    /* Optional: placeholder styling for contenteditable using data attribute */
    .editable:empty::before {
      content: attr(data-placeholder);
      color: #aaa;
    }
    
    /* Bottom half: for file upload and canvas */
    .bottom-half {
      flex: 1;              /* Take the other half */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    /* Style for the canvas in the bottom half */
    .bottom-half #upload-canvas {
      border: none;  /* Removed dashed border */
      width: 100%;
      flex: 1;
    }
    
    /* Diagonal lines styling (unchanged) */
    .line {
      position: absolute;
      background-color: black;
      height: 2px;         /* Line thickness */
    }
    
    /* The SVG container for the parallelogram (unchanged) */
    #parallelogram-svg {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;  /* Allow clicks to pass through */
    }
  </style>
</head>
<body>
  
  <div class="main-container">
    <!-- Top half for text input using contenteditable div -->
    <div class="top-half">
      <div class="editable" contenteditable="true" data-placeholder="intimately, not infinitely."></div>
    </div>
    <!-- Bottom half for file upload & canvas -->
    <div class="bottom-half">
      <canvas id="upload-canvas"></canvas>
    </div>
  </div>
  
  <!-- Diagonal lines (unchanged) -->
  <div class="line" id="line-top-left"></div>
  <div class="line" id="line-top-right"></div>
  <div class="line" id="line-bottom-left"></div>
  <div class="line" id="line-bottom-right"></div>
  
  <!-- SVG container for the parallelogram (unchanged) -->
  <svg id="parallelogram-svg">
    <!-- The polygon is drawn with no fill (only a stroke) -->
    <polygon id="parallelogram-poly" fill="none" stroke="black" stroke-width="2"></polygon>
  </svg>
  
  <script>
    function drawLinesAndParallelogram() {
      // 1. Get the container ("box") and its size/position in the viewport.
      const container = document.querySelector(".main-container");
      const rect = container.getBoundingClientRect();
      
      // 2. Convert the container's coordinates from the viewport to the full page.
      const containerPageRect = {
        left: rect.left + window.pageXOffset,
        top: rect.top + window.pageYOffset,
        right: rect.right + window.pageXOffset,
        bottom: rect.bottom + window.pageYOffset
      };
      
      // 3. Define minimum page dimensions.
      const minPageWidth = 500;
      const minPageHeight = 375;
      
      // 4. Use the maximum of the window's dimensions or the minimum values.
      let docWidth = Math.max(window.innerWidth, minPageWidth);
      let docHeight = Math.max(window.innerHeight, minPageHeight);
      
      // 5. Update the SVG container to cover the entire "document".
      const svg = document.getElementById("parallelogram-svg");
      svg.style.width = docWidth + "px";
      svg.style.height = docHeight + "px";
      
      // 6. Define the document (page) corners.
      const docCorners = {
        topLeft: { x: 0, y: 0 },
        topRight: { x: docWidth, y: 0 },
        bottomLeft: { x: 0, y: docHeight },
        bottomRight: { x: docWidth, y: docHeight }
      };
      
      // 7. Define the container's corners (in page coordinates).
      const corners = {
        topLeft: { x: containerPageRect.left, y: containerPageRect.top },
        topRight: { x: containerPageRect.right, y: containerPageRect.top },
        bottomLeft: { x: containerPageRect.left, y: containerPageRect.bottom },
        bottomRight: { x: containerPageRect.right, y: containerPageRect.bottom }
      };
      
      // 8. Helper function to calculate the distance between two points.
      function getDiagonalLength(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
      }
      
      // 9. Function to draw a diagonal line between two points.
      function setLine(lineId, start, end) {
        const line = document.getElementById(lineId);
        const length = getDiagonalLength(start.x, start.y, end.x, end.y);
        const angle = Math.atan2(end.y - start.y, end.x - start.x) * (180 / Math.PI);
        line.style.width = `${length}px`;
        line.style.transform = `rotate(${angle}deg)`;
        line.style.transformOrigin = "0 0";
        line.style.left = `${start.x}px`;
        line.style.top = `${start.y}px`;
      }
      
      // 10. Draw the four diagonal lines from the container's corners to the document's corners.
      setLine("line-top-left", corners.topLeft, docCorners.topLeft);
      setLine("line-top-right", corners.topRight, docCorners.topRight);
      setLine("line-bottom-left", corners.bottomLeft, docCorners.bottomLeft);
      setLine("line-bottom-right", corners.bottomRight, docCorners.bottomRight);
      
      // 11. Draw the parallelogram along the bottom-left diagonal.
      const desiredVerticalOffset = 100;  // Top edge shifted upward by 100px.
      const desiredBaseInset = 900;       // Inset from the bottom-left diagonal.
      const minEffectiveBaseLength = 60;
      const minVerticalOffset = 30;
      
      const P = { x: 0, y: docHeight };
      const Q = { x: corners.bottomLeft.x, y: corners.bottomLeft.y };
      
      const dx = Q.x - P.x;
      const dy = Q.y - P.y;
      const baseLength = Math.sqrt(dx * dx + dy * dy);
      const unit = { x: dx / baseLength, y: dy / baseLength };
      
      let baseInset = desiredBaseInset;
      let effectiveBaseLength = baseLength - 2 * baseInset;
      if (effectiveBaseLength < minEffectiveBaseLength) {
        baseInset = Math.max(0, (baseLength - minEffectiveBaseLength) / 2);
        effectiveBaseLength = baseLength - 2 * baseInset;
      }
      
      const A = { x: P.x + baseInset * unit.x, y: P.y + baseInset * unit.y }; // Lower left vertex
      const B = { x: Q.x - baseInset * unit.x, y: Q.y - baseInset * unit.y }; // Lower right vertex
      
      const verticalOffset = Math.max(desiredVerticalOffset, minVerticalOffset);
      const D = { x: A.x, y: A.y - verticalOffset }; // Upper left vertex
      const C = { x: B.x, y: B.y - verticalOffset }; // Upper right vertex
      
      const pointsStr = `${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y} ${D.x},${D.y}`;
      const polygon = document.getElementById("parallelogram-poly");
      polygon.setAttribute("points", pointsStr);
      
      // 12. Remove any previous horizontal lines (to avoid duplicates on resize)
      const oldHLines = document.querySelectorAll(".h-line");
      oldHLines.forEach(line => line.remove());
      
      // 13. Create horizontal lines between the bottom diagonal lines.
      const numHLines = 12;
      const spacingFactor = 0.1; // Controls the logarithmic spacing
      
      const yBottomBox = corners.bottomLeft.y;
      const yBottomDoc = docCorners.bottomLeft.y;
      
      // Reversed logarithmic distribution:
      for (let i = 0; i < numHLines; i++) {
          const t = Math.log(1 + (numHLines - 1 - i) * spacingFactor) /
                    Math.log(1 + (numHLines - 1) * spacingFactor);
          const y_line = yBottomBox + (1 - t) * (yBottomDoc - yBottomBox);
          
          const t_line = (y_line - yBottomBox) / (yBottomDoc - yBottomBox);
          const x_left = containerPageRect.left * (1 - t_line);
          const x_right = containerPageRect.right + t_line * (docWidth - containerPageRect.right);
          
          const hLine = document.createElement("div");
          hLine.className = "h-line";
          hLine.style.position = "absolute";
          hLine.style.top = y_line + "px";
          hLine.style.left = x_left + "px";
          hLine.style.width = (x_right - x_left) + "px";
          hLine.style.height = "2px";
          hLine.style.backgroundColor = "black";
          document.body.appendChild(hLine);
      }
    }
    
    window.onload = drawLinesAndParallelogram;
    window.onresize = drawLinesAndParallelogram;
  </script>
  
</body>
</html>
