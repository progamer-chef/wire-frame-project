<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    /* Basic Reset */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    /* Minimum page size */
    html, body {
      min-width: 500px;
      min-height: 375px;
    }
    
    /* Body fills viewport */
    body {
      font-family: monospace;
      height: 100vh;
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: hsl(0, 0%, 97%);
      position: relative;
      overflow: auto;
    }
    
    /* Main container styling */
    .main-container {
      width: 80vw;
      height: 65vh;
      min-width: 400px;
      min-height: 244px;
      border: 2px solid black;
      background-color: white;
      position: relative;
    }
    
    /* Top area now 33% of main-container */
    .top-half {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 33%;
      overflow: hidden;
    }
    
    /* Bottom area now occupies 67% of main-container */
    .bottom-half {
      position: absolute;
      top: 33%;
      left: 0;
      width: 100%;
      height: 67%;
      overflow: hidden;
      padding: 10px;
    }
    
    /* Contenteditable text input */
    .editable {
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      text-align: center;
      font-family: "Times New Roman", Times, serif;
      color: black;
      font-weight: bold;
      font-size: 1rem;
      border: none;
      outline: none;
    }
    
    .editable:empty::before {
      content: attr(data-placeholder);
      color: #aaa;
    }
    
    /* Hide file input UI */
    #file-input {
      display: none;
    }
    
    /* Upload container for files */
    #upload-container {
      width: 100%;
      height: calc(100% - 40px);
      overflow: hidden;
      position: relative;
      background-color: #FFFFFF;
    }
    
    /* File box styling â€“ no visible border, absolute positioning */
    .file-box {
      overflow: hidden;
      position: absolute;
      cursor: move;
      user-select: none;
    }
    
    /* Glowing light-blue boundary on hover for file boxes */
    .file-box:hover {
      outline: 2px solid #ADD8E6;
      box-shadow: 0 0 8px #ADD8E6;
    }
    
    /* Images: fill container exactly */
    .file-box img {
      width: 100%;
      height: 100%;
      object-fit: fill;
      pointer-events: none;
    }
    
    /* Videos: fill container exactly; pointer events disabled in room mode */
    .file-box video {
      width: 100%;
      height: 100%;
      object-fit: fill;
      pointer-events: none;
    }
    
    /* Audio visual representation: red/blue box */
    .audio-box {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    .audio-box .top-half {
      background-color: red;
      flex: 1;
    }
    .audio-box .bottom-half {
      background-color: blue;
      flex: 1;
    }
    
    /* Diagonal lines */
    .line {
      position: absolute;
      background-color: black;
      height: 2px;
    }
    
    /* SVG container for parallelogram */
    #parallelogram-svg {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    
    /* --- View Mode Styles (detail view) ---
         This section controls the presentation of view mode.
         You can change padding, fonts, etc., here.
    */
    #detail-view {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: white;
      display: none;
      z-index: 1000;
    }
    .detail-layout {
      display: flex;
      width: 100%;
      height: 100%;
    }
    /* For horizontal layout: file on top, textbox bottom */
    .detail-layout.horizontal {
      flex-direction: column;
    }
    /* For vertical layout: file on right, textbox left */
    .detail-layout.vertical {
      flex-direction: row;
    }
    /* Special layout for audio: center everything */
    .detail-layout.audio {
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .detail-layout.audio > #detail-file-container {
      margin-bottom: 20px;
    }
    .detail-layout.audio > #detail-text-container {
      width: 50%;
    }
    .detail-layout > div {
      box-sizing: border-box;
      overflow: auto;
      margin: 0;
      padding: 0;
      border: none;
    }
    /* Horizontal layout dimensions */
    #detail-file-container.horizontal,
    #detail-text-container.horizontal {
      width: 100%;
      height: 50%;
    }
    /* Vertical layout dimensions */
    #detail-file-container.vertical,
    #detail-text-container.vertical {
      width: 50%;
      height: 100%;
    }
    /* Make media in view mode scale nicely */
    #detail-file-container img,
    #detail-file-container video,
    #detail-file-container audio,
    #detail-file-container .audio-box {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      display: block;
      margin: auto;
    }
    /* Detail textbox styling (view mode) */
    #detail-text {
      width: 100%;
      height: 100%;
      font-family: monospace;
      font-size: 1rem;
      padding: 10px;
      box-sizing: border-box;
      border: none;
      resize: none;
    }
    /* Close button styling */
    #detail-close {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 5px 10px;
      z-index: 1100;
      cursor: pointer;
    }
  </style>
</head>
<body>
  
  <div class="main-container">
    <!-- Top area for text input -->
    <div class="top-half">
      <div class="editable" contenteditable="true" data-placeholder="intimately, not infinitely."></div>
    </div>
    <!-- Bottom area for file uploads -->
    <div class="bottom-half">
      <input type="file" id="file-input" multiple accept="image/*,video/*,audio/*">
      <div id="upload-container"></div>
    </div>
  </div>
  
  <!-- Diagonal lines -->
  <div class="line" id="line-top-left"></div>
  <div class="line" id="line-top-right"></div>
  <div class="line" id="line-bottom-left"></div>
  <div class="line" id="line-bottom-right"></div>
  
  <!-- SVG container for parallelogram -->
  <svg id="parallelogram-svg">
    <polygon id="parallelogram-poly" fill="none" stroke="black" stroke-width="2"></polygon>
  </svg>
  
  <!-- View mode overlay (detail view) -->
  <div id="detail-view">
    <button id="detail-close">Close</button>
    <!-- The view mode layout will be generated dynamically here -->
  </div>
  
  <script>
    // Global variable to track playable media moved to view mode.
    // For audio, we store both the hidden <audio> element and the visual (audio-box).
    let currentDetailMediaInfo = null;
    
    // DRAWING FUNCTIONS (unchanged)
    function drawLinesAndParallelogram() {
      const container = document.querySelector(".main-container");
      const rect = container.getBoundingClientRect();
      
      const containerPageRect = {
        left: rect.left + window.pageXOffset,
        top: rect.top + window.pageYOffset,
        right: rect.right + window.pageXOffset,
        bottom: rect.bottom + window.pageYOffset
      };
      
      const minPageWidth = 500;
      const minPageHeight = 375;
      let docWidth = Math.max(window.innerWidth, minPageWidth);
      let docHeight = Math.max(window.innerHeight, minPageHeight);
      
      const svg = document.getElementById("parallelogram-svg");
      svg.style.width = docWidth + "px";
      svg.style.height = docHeight + "px";
      
      const docCorners = {
        topLeft: { x: 0, y: 0 },
        topRight: { x: docWidth, y: 0 },
        bottomLeft: { x: 0, y: docHeight },
        bottomRight: { x: docWidth, y: docHeight }
      };
      
      const corners = {
        topLeft: { x: containerPageRect.left, y: containerPageRect.top },
        topRight: { x: containerPageRect.right, y: containerPageRect.top },
        bottomLeft: { x: containerPageRect.left, y: containerPageRect.bottom },
        bottomRight: { x: containerPageRect.right, y: containerPageRect.bottom }
      };
      
      function getDiagonalLength(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
      }
      
      function setLine(lineId, start, end) {
        const line = document.getElementById(lineId);
        const length = getDiagonalLength(start.x, start.y, end.x, end.y);
        const angle = Math.atan2(end.y - start.y, end.x - start.x) * (180 / Math.PI);
        line.style.width = `${length}px`;
        line.style.transform = `rotate(${angle}deg)`;
        line.style.transformOrigin = "0 0";
        line.style.left = `${start.x}px`;
        line.style.top = `${start.y}px`;
      }
      
      setLine("line-top-left", corners.topLeft, docCorners.topLeft);
      setLine("line-top-right", corners.topRight, docCorners.topRight);
      setLine("line-bottom-left", corners.bottomLeft, docCorners.bottomLeft);
      setLine("line-bottom-right", corners.bottomRight, docCorners.bottomRight);
      
      const desiredVerticalOffset = 100;
      const desiredBaseInset = 900;
      const minEffectiveBaseLength = 60;
      const minVerticalOffset = 30;
      
      const P = { x: 0, y: docHeight };
      const Q = { x: corners.bottomLeft.x, y: corners.bottomLeft.y };
      const dx = Q.x - P.x;
      const dy = Q.y - P.y;
      const baseLength = Math.sqrt(dx * dx + dy * dy);
      const unit = { x: dx / baseLength, y: dy / baseLength };
      
      let baseInset = desiredBaseInset;
      let effectiveBaseLength = baseLength - 2 * baseInset;
      if (effectiveBaseLength < minEffectiveBaseLength) {
        baseInset = Math.max(0, (baseLength - minEffectiveBaseLength) / 2);
        effectiveBaseLength = baseLength - 2 * baseInset;
      }
      
      const A = { x: P.x + baseInset * unit.x, y: P.y + baseInset * unit.y };
      const B = { x: Q.x - baseInset * unit.x, y: Q.y - baseInset * unit.y };
      const verticalOffset = Math.max(desiredVerticalOffset, minVerticalOffset);
      const D = { x: A.x, y: A.y - verticalOffset };
      const C = { x: B.x, y: B.y - verticalOffset };
      const pointsStr = `${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y} ${D.x},${D.y}`;
      
      const polygon = document.getElementById("parallelogram-poly");
      polygon.setAttribute("points", pointsStr);
      
      const oldHLines = document.querySelectorAll(".h-line");
      oldHLines.forEach(line => line.remove());
      
      const numHLines = 12;
      const spacingFactor = 0.1;
      const yBottomBox = corners.bottomLeft.y;
      const yBottomDoc = docCorners.bottomLeft.y;
      
      for (let i = 0; i < numHLines; i++) {
          const t = Math.log(1 + (numHLines - 1 - i) * spacingFactor) /
                    Math.log(1 + (numHLines - 1) * spacingFactor);
          const y_line = yBottomBox + (1 - t) * (yBottomDoc - yBottomBox);
          const t_line = (y_line - yBottomBox) / (yBottomDoc - yBottomBox);
          const x_left = containerPageRect.left * (1 - t_line);
          const x_right = containerPageRect.right + t_line * (docWidth - containerPageRect.right);
          const hLine = document.createElement("div");
          hLine.className = "h-line";
          hLine.style.position = "absolute";
          hLine.style.top = y_line + "px";
          hLine.style.left = x_left + "px";
          hLine.style.width = (x_right - x_left) + "px";
          hLine.style.height = "2px";
          hLine.style.backgroundColor = "black";
          document.body.appendChild(hLine);
      }
    }
    
    // ------------------------------
    // DRAG & DROP / FILE HANDLING
    // ------------------------------
    
    function setupDragAndDrop() {
      const uploadContainer = document.getElementById("upload-container");
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        uploadContainer.addEventListener(eventName, (e) => {
          e.preventDefault();
          e.stopPropagation();
        });
      });
      
      uploadContainer.addEventListener('dragover', () => {
        uploadContainer.style.backgroundColor = "#D3D3D3";
      });
      
      uploadContainer.addEventListener('dragleave', () => {
        uploadContainer.style.backgroundColor = "#FFFFFF";
      });
      
      uploadContainer.addEventListener('drop', (e) => {
        uploadContainer.style.backgroundColor = "#FFFFFF";
        const files = e.dataTransfer.files;
        handleFiles(files);
      });
    }
    
    function handleFiles(files) {
      const uploadContainer = document.getElementById("upload-container");
      // Limit maximum of 3 files.
      for (let file of files) {
        if (uploadContainer.children.length >= 3) {
          alert("3 files maximum");
          break;
        }
        createFileBox(file);
      }
    }
    
    // Create a file box for a given file.
    function createFileBox(file) {
      const uploadContainer = document.getElementById("upload-container");
      const fileBox = document.createElement("div");
      fileBox.classList.add("file-box");
      
      // For each file type, size the box to match the file (or scale down if needed)
      if (file.type.startsWith("image/")) {
        const img = new Image();
        img.onload = function() {
          const naturalWidth = img.naturalWidth;
          const naturalHeight = img.naturalHeight;
          const scale = Math.min(1, uploadContainer.clientWidth / naturalWidth, uploadContainer.clientHeight / naturalHeight);
          const newWidth = naturalWidth * scale;
          const newHeight = naturalHeight * scale;
          fileBox.style.width = newWidth + "px";
          fileBox.style.height = newHeight + "px";
          // Center the file box.
          fileBox.style.left = ((uploadContainer.clientWidth - newWidth) / 2) + "px";
          fileBox.style.top = ((uploadContainer.clientHeight - newHeight) / 2) + "px";
          fileBox.appendChild(img);
          fileBox.mediaType = "image";
          fileBox.mediaElement = img;
          saveRelativeDimensions(fileBox, uploadContainer);
          makeInteractive(fileBox);
        };
        img.src = URL.createObjectURL(file);
      } else if (file.type.startsWith("video/")) {
        const video = document.createElement("video");
        video.loop = true;
        video.controls = false;
        // In room mode, pointer events are disabled so that drag/resize works.
        video.style.pointerEvents = "none";
        video.onloadedmetadata = function() {
          const naturalWidth = video.videoWidth;
          const naturalHeight = video.videoHeight;
          const scale = Math.min(1, uploadContainer.clientWidth / naturalWidth, uploadContainer.clientHeight / naturalHeight);
          const newWidth = naturalWidth * scale;
          const newHeight = naturalHeight * scale;
          fileBox.style.width = newWidth + "px";
          fileBox.style.height = newHeight + "px";
          fileBox.style.left = ((uploadContainer.clientWidth - newWidth) / 2) + "px";
          fileBox.style.top = ((uploadContainer.clientHeight - newHeight) / 2) + "px";
          fileBox.appendChild(video);
          fileBox.mediaType = "video";
          fileBox.mediaElement = video;
          saveRelativeDimensions(fileBox, uploadContainer);
          makeInteractive(fileBox);
        };
        video.src = URL.createObjectURL(file);
      } else if (file.type.startsWith("audio/")) {
        // For audio, use fixed height of 50px and width = container width.
        const newWidth = uploadContainer.clientWidth;
        const newHeight = 50;
        fileBox.style.width = newWidth + "px";
        fileBox.style.height = newHeight + "px";
        fileBox.style.left = ((uploadContainer.clientWidth - newWidth) / 2) + "px";
        fileBox.style.top = ((uploadContainer.clientHeight - newHeight) / 2) + "px";
        // Create hidden audio element.
        const audio = document.createElement("audio");
        audio.loop = true;
        audio.controls = false;
        audio.style.display = "none";
        audio.src = URL.createObjectURL(file);
        // Create visual representation.
        const audioBox = document.createElement("div");
        audioBox.className = "audio-box";
        const topDiv = document.createElement("div");
        topDiv.className = "top-half";
        const bottomDiv = document.createElement("div");
        bottomDiv.className = "bottom-half";
        audioBox.appendChild(topDiv);
        audioBox.appendChild(bottomDiv);
        fileBox.appendChild(audioBox);
        fileBox.appendChild(audio); // hidden element
        fileBox.mediaType = "audio";
        fileBox.mediaElement = audio;
        fileBox.audioVisual = audioBox;
        saveRelativeDimensions(fileBox, uploadContainer);
        makeInteractive(fileBox);
        // Attach event listeners to update audio visual colors in both modes.
        audio.addEventListener("play", () => {
          if (fileBox.audioVisual) {
            updateAudioVisualColors(audio, fileBox.audioVisual);
          }
          if (currentDetailMediaInfo && currentDetailMediaInfo.fileBox === fileBox && currentDetailMediaInfo.mediaVisual) {
            updateAudioVisualColors(audio, currentDetailMediaInfo.mediaVisual);
          }
        });
        audio.addEventListener("pause", () => {
          if (fileBox.audioVisual) {
            updateAudioVisualColors(audio, fileBox.audioVisual);
          }
          if (currentDetailMediaInfo && currentDetailMediaInfo.fileBox === fileBox && currentDetailMediaInfo.mediaVisual) {
            updateAudioVisualColors(audio, currentDetailMediaInfo.mediaVisual);
          }
        });
        // Initialize colors.
        updateAudioVisualColors(audio, fileBox.audioVisual);
      } else {
        // For other files, use a default 200x200 size.
        const newWidth = 200;
        const newHeight = 200;
        fileBox.style.width = newWidth + "px";
        fileBox.style.height = newHeight + "px";
        fileBox.style.left = ((uploadContainer.clientWidth - newWidth) / 2) + "px";
        fileBox.style.top = ((uploadContainer.clientHeight - newHeight) / 2) + "px";
        const fileLink = document.createElement("a");
        fileLink.href = URL.createObjectURL(file);
        fileLink.textContent = file.name;
        fileLink.target = "_blank";
        fileBox.appendChild(fileLink);
        saveRelativeDimensions(fileBox, uploadContainer);
        makeInteractive(fileBox);
      }
      
      // Right-click to delete (cut) the file.
      fileBox.addEventListener("contextmenu", function(e) {
        e.preventDefault();
        if (confirm("Cut file?")) {
          fileBox.remove();
        }
      });
      
      // Single click to toggle play/pause for video/audio in room mode.
      fileBox.addEventListener("click", function(e) {
        if (fileBox.mediaType === "video" || fileBox.mediaType === "audio") {
          const media = fileBox.mediaElement;
          if (media.paused){
            media.play();
          } else {
            media.pause();
          }
        }
      });
      
      // Double-click to open view mode.
      fileBox.addEventListener("dblclick", function(e) {
        openDetailView(fileBox);
      });
      
      uploadContainer.appendChild(fileBox);
    }
    
    // Save fileBox dimensions as percentages relative to its container.
    function saveRelativeDimensions(el, container) {
      el.dataset.relLeft = parseFloat(el.style.left) / container.clientWidth;
      el.dataset.relTop = parseFloat(el.style.top) / container.clientHeight;
      el.dataset.relWidth = parseFloat(el.style.width) / container.clientWidth;
      el.dataset.relHeight = parseFloat(el.style.height) / container.clientHeight;
    }
    
    // Update file boxes on window resize.
    function updateFileBoxesPositions() {
      const uploadContainer = document.getElementById("upload-container");
      for (const fileBox of uploadContainer.children) {
        if (fileBox.dataset.relLeft) {
          fileBox.style.left = (parseFloat(fileBox.dataset.relLeft) * uploadContainer.clientWidth) + "px";
          fileBox.style.top = (parseFloat(fileBox.dataset.relTop) * uploadContainer.clientHeight) + "px";
          fileBox.style.width = (parseFloat(fileBox.dataset.relWidth) * uploadContainer.clientWidth) + "px";
          fileBox.style.height = (parseFloat(fileBox.dataset.relHeight) * uploadContainer.clientHeight) + "px";
        }
      }
    }
    
    // ------------------------------
    // INTERACTIVE (DRAG & RESIZE) FUNCTIONALITY
    // ------------------------------
    
    function makeInteractive(el) {
      const threshold = 10; // pixels from any corner to trigger resizing
      
      el.addEventListener("mousedown", function(e) {
        // Prevent text selection during drag/resize.
        e.preventDefault();
        
        const rect = {
          left: el.offsetLeft,
          top: el.offsetTop,
          width: el.offsetWidth,
          height: el.offsetHeight
        };
        const relativeX = e.offsetX;
        const relativeY = e.offsetY;
        let corner = null;
        if (relativeX < threshold && relativeY < threshold) {
          corner = "top-left";
        } else if (relativeX > rect.width - threshold && relativeY < threshold) {
          corner = "top-right";
        } else if (relativeX < threshold && relativeY > rect.height - threshold) {
          corner = "bottom-left";
        } else if (relativeX > rect.width - threshold && relativeY > rect.height - threshold) {
          corner = "bottom-right";
        }
        
        const parent = el.parentElement;
        
        // Helper to update dataset after movement.
        function updateRelative() {
          el.dataset.relLeft = parseFloat(el.style.left) / parent.clientWidth;
          el.dataset.relTop = parseFloat(el.style.top) / parent.clientHeight;
          el.dataset.relWidth = parseFloat(el.style.width) / parent.clientWidth;
          el.dataset.relHeight = parseFloat(el.style.height) / parent.clientHeight;
        }
        
        if (corner) {
          // RESIZE mode:
          if (corner === "top-left" || corner === "bottom-right") {
            document.body.style.cursor = "nwse-resize";
          } else {
            document.body.style.cursor = "nesw-resize";
          }
          const startX = e.clientX, startY = e.clientY;
          const startWidth = rect.width, startHeight = rect.height;
          const startLeft = rect.left, startTop = rect.top;
          
          function resizeMove(ev) {
            const dx = ev.clientX - startX;
            const dy = ev.clientY - startY;
            let newWidth = startWidth, newHeight = startHeight;
            let newLeft = startLeft, newTop = startTop;
            
            if (corner === "top-left") {
              newWidth = startWidth - dx;
              newHeight = startHeight - dy;
              newLeft = startLeft + dx;
              newTop = startTop + dy;
            } else if (corner === "top-right") {
              newWidth = startWidth + dx;
              newHeight = startHeight - dy;
              newTop = startTop + dy;
            } else if (corner === "bottom-left") {
              newWidth = startWidth - dx;
              newHeight = startHeight + dy;
              newLeft = startLeft + dx;
            } else if (corner === "bottom-right") {
              newWidth = startWidth + dx;
              newHeight = startHeight + dy;
            }
            
            newWidth = Math.max(newWidth, 30);
            newHeight = Math.max(newHeight, 30);
            
            newLeft = Math.max(0, newLeft);
            newTop = Math.max(0, newTop);
            if(newLeft + newWidth > parent.clientWidth){
              newWidth = parent.clientWidth - newLeft;
            }
            if(newTop + newHeight > parent.clientHeight){
              newHeight = parent.clientHeight - newTop;
            }
            
            el.style.width = newWidth + "px";
            el.style.height = newHeight + "px";
            el.style.left = newLeft + "px";
            el.style.top = newTop + "px";
          }
          
          function resizeEnd() {
            document.body.style.cursor = "default";
            document.removeEventListener("mousemove", resizeMove);
            document.removeEventListener("mouseup", resizeEnd);
            updateRelative();
          }
          
          document.addEventListener("mousemove", resizeMove);
          document.addEventListener("mouseup", resizeEnd);
        } else {
          // DRAG mode:
          parent.style.outline = "2px solid red";
          
          const startX = e.clientX, startY = e.clientY;
          const startLeft = el.offsetLeft;
          const startTop = el.offsetTop;
          
          function dragMove(ev) {
            const dx = ev.clientX - startX;
            const dy = ev.clientY - startY;
            let newLeft = startLeft + dx;
            let newTop = startTop + dy;
            newLeft = Math.max(0, Math.min(newLeft, parent.clientWidth - el.offsetWidth));
            newTop = Math.max(0, Math.min(newTop, parent.clientHeight - el.offsetHeight));
            el.style.left = newLeft + "px";
            el.style.top = newTop + "px";
          }
          
          function dragEnd() {
            parent.style.outline = "";
            document.removeEventListener("mousemove", dragMove);
            document.removeEventListener("mouseup", dragEnd);
            updateRelative();
          }
          
          document.addEventListener("mousemove", dragMove);
          document.addEventListener("mouseup", dragEnd);
        }
      });
    }
    
    // ------------------------------
    // VIEW MODE FUNCTIONALITY (Double-Click)
    // ------------------------------
    
    function openDetailView(fileBox) {
      const detailView = document.getElementById("detail-view");
      detailView.style.display = "block";
      
      // Clear any existing view mode layout (except the close button)
      detailView.querySelectorAll(".detail-layout").forEach(el => el.remove());
      
      // For non-audio files, determine dimensions.
      let fileWidth = fileBox.offsetWidth;
      let fileHeight = fileBox.offsetHeight;
      
      // Decide on layout.
      let layoutType;
      if (fileBox.mediaType === "audio") {
        layoutType = "audio";
      } else {
        layoutType = (fileWidth > fileHeight) ? "horizontal" : "vertical";
      }
      
      // Create the layout container.
      const layoutDiv = document.createElement("div");
      layoutDiv.classList.add("detail-layout", layoutType);
      
      // Create file and text containers.
      const fileContainer = document.createElement("div");
      fileContainer.id = "detail-file-container";
      fileContainer.classList.add(layoutType);
      const textContainer = document.createElement("div");
      textContainer.id = "detail-text-container";
      textContainer.classList.add(layoutType);
      
      let mediaElement;
      if (fileBox.mediaType === "video") {
        // For video, move the same media element.
        mediaElement = fileBox.mediaElement;
        // Remove the room mode pointer-events so that clicks work in view mode.
        mediaElement.style.pointerEvents = "auto";
        if (mediaElement.parentElement === fileBox) {
          fileBox.removeChild(mediaElement);
        }
        currentDetailMediaInfo = { fileBox: fileBox, mediaElement: mediaElement };
        mediaElement.addEventListener("click", toggleMediaPlay);
      } else if (fileBox.mediaType === "audio") {
        // For audio, move the audio visual representation.
        mediaElement = fileBox.audioVisual;
        if (mediaElement.parentElement === fileBox) {
          fileBox.removeChild(mediaElement);
        }
        currentDetailMediaInfo = { fileBox: fileBox, mediaVisual: mediaElement, mediaElement: fileBox.mediaElement };
        mediaElement.addEventListener("click", audioVisualToggle);
        // Update colors based on current play state.
        updateAudioVisualColors(fileBox.mediaElement, mediaElement);
        // Also update colors when play/pause events occur.
        fileBox.mediaElement.addEventListener("play", () => updateAudioVisualColors(fileBox.mediaElement, mediaElement));
        fileBox.mediaElement.addEventListener("pause", () => updateAudioVisualColors(fileBox.mediaElement, mediaElement));
      } else if (fileBox.mediaType === "image") {
        mediaElement = document.createElement("img");
        mediaElement.src = fileBox.querySelector("img").src;
      } else {
        mediaElement = fileBox.cloneNode(true);
      }
      
      fileContainer.appendChild(mediaElement);
      
      // Create the textbox.
      const textBox = document.createElement("textarea");
      textBox.id = "detail-text";
      textBox.placeholder = "Enter text here...";
      textContainer.appendChild(textBox);
      
      // Append containers to layout.
      if (layoutType === "horizontal") {
        layoutDiv.appendChild(fileContainer);
        layoutDiv.appendChild(textContainer);
      } else if (layoutType === "vertical") {
        layoutDiv.appendChild(textContainer);
        layoutDiv.appendChild(fileContainer);
      } else if (layoutType === "audio") {
        // For audio, place the audio visual above the textbox (centered by CSS).
        layoutDiv.appendChild(fileContainer);
        layoutDiv.appendChild(textContainer);
      }
      
      detailView.appendChild(layoutDiv);
    }
    
    // Toggle play/pause for video elements in view mode.
    function toggleMediaPlay(e) {
      const media = e.currentTarget;
      if (media.paused) {
        media.play();
      } else {
        media.pause();
      }
    }
    
    // Toggle play/pause for audio via the visual representation.
    function audioVisualToggle(e) {
      if (!currentDetailMediaInfo || !currentDetailMediaInfo.mediaElement) return;
      const audio = currentDetailMediaInfo.mediaElement;
      if (audio.paused) {
        audio.play();
      } else {
        audio.pause();
      }
      updateAudioVisualColors(audio, currentDetailMediaInfo.mediaVisual);
    }
    
    // Update the audio visual colors based on the play state.
    // Accepts a second parameter 'visual' which is the audio visual element to update.
    function updateAudioVisualColors(audio, visual) {
      if (!audio || !visual) return;
      const topDiv = visual.querySelector('.top-half');
      const bottomDiv = visual.querySelector('.bottom-half');
      if (audio.paused) {
        topDiv.style.backgroundColor = "red";
        bottomDiv.style.backgroundColor = "blue";
      } else {
        topDiv.style.backgroundColor = "#2fff00";
        bottomDiv.style.backgroundColor = "#b400ff";
      }
    }
    
    // Close view mode.
    document.getElementById("detail-close").addEventListener("click", function() {
      const detailView = document.getElementById("detail-view");
      detailView.style.display = "none";
      
      if (currentDetailMediaInfo) {
        // Remove view-mode event listeners.
        if (currentDetailMediaInfo.mediaVisual) {
          currentDetailMediaInfo.mediaVisual.removeEventListener("click", audioVisualToggle);
        } else if (currentDetailMediaInfo.mediaElement &&
                   currentDetailMediaInfo.mediaElement.tagName.toLowerCase() === "video") {
          currentDetailMediaInfo.mediaElement.removeEventListener("click", toggleMediaPlay);
          // Restore pointer-events for room mode.
          currentDetailMediaInfo.mediaElement.style.pointerEvents = "none";
        }
        // Reattach the media element (or audio visual) to its original fileBox.
        if (currentDetailMediaInfo.mediaVisual) {
          currentDetailMediaInfo.fileBox.appendChild(currentDetailMediaInfo.mediaVisual);
        } else {
          currentDetailMediaInfo.fileBox.appendChild(currentDetailMediaInfo.mediaElement);
        }
        currentDetailMediaInfo = null;
      }
    });
    
    // ------------------------------
    // WINDOW LOAD & RESIZE
    // ------------------------------
    
    window.onload = function() {
      drawLinesAndParallelogram();
      
      const fileInput = document.getElementById("file-input");
      fileInput.addEventListener("change", function(e) {
        handleFiles(e.target.files);
      });
      
      setupDragAndDrop();
    };
    
    window.onresize = function() {
      drawLinesAndParallelogram();
      updateFileBoxesPositions();
    };
  </script>
  
</body>
</html>
